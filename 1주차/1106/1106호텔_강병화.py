import sys

INF = 1e9

si = sys.stdin.readline

c, n = map(int, si().split())

dp = [INF] * (c + 100) # 1100을 최댓값으로 잡는 이유는 한 도시에서 늘릴수 있는 고객수가 100명이라면 이 100명부터 1000명까지 전부 최소비용을 확인하려면 늘려주어야 가능하다

                        # 그렇게 하지 않으면 dp테이블을 채울시 최대 900명 늘리는데까지만 체크하게 된다
dp[0] = 0 # 0명을 늘리기 위해 드는 최소비용은 0으로 초기화

data = []

for _ in range(n):
    cost,cust = map(int, si().split())
    data.append([cost,cust])


# sorted_data = data.sort(key=lambda x : x[0]) # 어차피 최소값은 갱신되므로 굳이 그리디방식을 택할 필요는 없음
answer = INF
for cost, cust in data: # 각 도시가 늘릴수 있는 인원수가 마지막일 때 그 전의 단계의 최소비용을 이용하여 구한다

    for i in range(cust, c + 100):

        dp[i] = min(dp[i] , dp[i-cust] + cost) # 5명의 고객수를 늘리는데 드는 비용 3(1번도시)과 5(2번도시)중 최소는 3이 저장됨 => 최적부분구조
        # 목표로하는 고객인원수 이상이 되면 계속 최소값을 즉 최종정답을 업데이트 때리면 시간을 절감할 수 있다.
        if i >= c:
            answer = min(answer , dp[i])
        # 한도시의 늘릴 수 있는 고객수가 5명이고 비용이 3이라면 그 이전의 1명 2명 3명 4명의 수를 늘리는데 드는 최소비용은 비교할 필요가 없다
        # 최소 5명을 늘리는데 드는 비용이 3으로 고정되어 있으므로 그 이전의 고객수들을 늘리는데 드는 비용과 동일하다
        # 즉 이미 최소고객수이고 최소비용이다 그 자체 값으로
        # 따라서 최소 고객수가 5이후인 값을 갱신해나가면 된다 dp[1] + cost , dp[2] + cost , dp[3] + cost .... dp[106] + cost
# print(min(dp[c:]))  dp테이블에 저장된 각 고객별 최소비용을 불러와 최솟값을 구한다 단 , c명이상인 경우에만 최소값을 돌리는 것에 유의한다
print(answer)
# 12명의 고객수를 늘리기 위해 드는 최소비용은 12명 이상이므로 13명을 늘리는데 최소비용이 될수있음에 유의해야한다
# 즉 인원수는 초과하지만 더 최소비용이 되는 경우를 고려해야한다
