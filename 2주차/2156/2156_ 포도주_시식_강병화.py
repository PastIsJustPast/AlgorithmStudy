# # 처음에 문제를 읽고 경우의 수가 많다고 생각하였다 혹은 복잡하다고 생각하였다
# # 최대로 포도주의 양을 마시기 위해서 3잔을 연속으로 마시지 않으면서 마시는 포도주의 양 중 최댓갑승ㄹ
# # 구하는 최적부분 구조는 완전탐색 혹은 DP로 해결할 수 있다
# # 포도주가 오직 선형으로 늘어져 있고 꼭 2잔연속으로 안마셔도 되고 1잔마시고 띄우고 그다음 두잔을 마셔도 되는
# # 다양한 경우의 수가 나오면 복잡도는 기본적으로 N^2 가 나오게 된다
# # 예를 들어 6 10 13 9 8 1 이면 6 10 9 8 이 정답이고
# # 10 13 8 1 을 선택해도 되고 6 13 9 1을 선택해도 된다
# # 여튼 3잔연속으로 고르지 않으면서 고를 수 있는 경우의 수는 많다 n은 10000제한이다
# # 10 9 8 을 고를수도 있다
# # 그래서 i번째 포도주를 마실때 그 이전의 값을 활용하여 최댓값을 저장해나가다보면 마지막 포도주잔을 마시려고 할때 최댓값을 구하면 된다
# # 키워드는 3번연속 마실 수 없다이고 6을 마시면 10까지 마실수잇고 6을 안마시면 10 13을 마실수잇으므로
# # 두가지의 상황을 다르게 설정해서 최댓값을 비교해야한다
# # 그래서 0번연속과 1번연속과 2번연속으로 나누어서 설정해야하므로 2차원 dp를 사용해서 풀이하려고 한다
# # 1번연속이라면 현재 포도주를 마시고 2번연속이라면 현재포도주를 마시지 않는것중 두개의 값을 비교해 최대값을 저장해갈것이다
# # 초기값은 첫값은 마시냐 안마시냐 두가지 경우이므로 dp[0][0] = 0 dp[0][1] = arr[0]
# import sys
# si = sys.stdin.readline
#
# N = int(si())
# grape_juices = []
# for _ in range(N):
#     grape_juices.append(int(si()))
# dp = [[0 for _ in range(3)] for i in range(N+1)]
# dp[1][0] = dp[0][2] # 앞에 0번 연속마셧을때 이번에 마시는 경우
# dp[1][1] = grape_juices[0]
# dp[1][2] = grape_juices[0]
# for i in range(2,N+1):
#     dp[i][0] = dp[i-1][2]
#     dp[i][1] = dp[i-2][2] + grape_juices[i-1]
#     dp[i][2] = dp[i-1][1] + grape_juices[i-1]
# print(max(dp[N][0],dp[N][1],dp[N][2]))
# 위의 풀이로 하면 최적구조가 되지 않는다 모든 경우의 수를 고려하지 않기때문이다 가령 1개씩 연속되고 끈히곡
# 하는 부분일때 경우의 수를 고려하지 않아서 틀린답이된다


# 점화식 i번째잔을 마실때 최대 마시는 포도주량
n = int(input())

wine = []

for i in range(n):
    wine.append(int(input()))

d = [0]*n

d[0] = wine[0]
if n > 1:
    d[1] = wine[0]+wine[1]

if n > 2:
    # 3잔째에는 앞의 두잔 모두 마시고 3잔째 안마시는 경우와 3잔째마시기는 하는데 그 전잔을 마시고 3잔째 마시거나 그 전전잔을 마시고 3잔째 마시는 경우의 수이다
    d[2] = max(wine[2]+wine[1], wine[2]+wine[0], d[1])

for i in range(3, n):
    d[i] = max(d[i-1], d[i-3]+wine[i-1]+wine[i], d[i-2]+wine[i])

print(d[n-1])

